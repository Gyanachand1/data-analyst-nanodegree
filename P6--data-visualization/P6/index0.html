<!DOCTYPE html>
<meta charset="utf-8">
<head>
<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">

<style>

    body{ 
      color: #444; 
      background: #f3f3f3; 
      font: normal 12px "Lato", sans-serif;
      margin: 2em; }
    header { 
      margin: 0 0 20px 220px; 
      border-bottom: 1px solid #6c6c6c; 
      width: 360px; 
      position: relative; }

    h1     { 
      font-size: 28px; 
      font-weight: normal; 
      text-shadow: #fff 0 1px 0; 
      margin: 0 0 0 0; 
      padding: 0; 
    }
    small  { 
      color: #a3a3a3; 
      font-size: 12px; 
      position: absolute; 
      bottom: -1.8em; 
      left: 0;
    }
    a{ 
      color: #a3a3a3; 
    }

    span.label_year:hover { 
      cursor: ew-resize; 
    }

    text.label { fill: #444; }
    text.label.start { text-anchor: end; }
    line.slope { stroke: #444; stroke-width: 1; }

    .missing text.label { display: none; }
    .missing line.slope { display: none; }

    .over text.label { fill: #bb2629; }
    .over line.slope { stroke: #bb2629; stroke-width: 2; }


</style>
<script src="//d3js.org/d3.v3.min.js" charset="utf-8"></script>
</head>
<div id="chart"></div>

<script>
// REFERENCES:
//http://bl.ocks.org/zbjornson/2547496

// var w = 960,
//     h = 500;

//var margin = {top: 20, right: 30, bottom: 30, left: 60};
//     width = w - margin.left - margin.right,
//     height = h- margin.top - margin.bottom;

// var font_size = 12
// var interval = 20;

// var chart = d3.select(".chart").append("svg")
//     .attr("width", width + margin.left + margin.right)
//     .attr("height", height + margin.top + margin.bottom)
//     .append("g")
//     .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
function get_bin(edad, interval = 10) {
  return Math.floor(parseInt(edad) / interval) * interval;
}

var hombres = [];
var mujeres = [];
var p = []

var dataset = {}; 
var data_series= [];

d3.csv("./data/data_dict.csv",function(error, data){ 
    data.forEach(function(d) {
        data_series.push(d["Indicator Name"]);
    });
});

indicator_pair = [data_series[1], data_series[2]];
indicator_list = []
d3.csv("./data/data.csv",function(error, data){

    data.forEach(function(d) {
    //selection of the year column
        d["2014"] = +d["2014"];
    });
  leftVar = "Health expenditure per capita (current US$)";
  rightVar = "Life expectancy at birth, total (years)";
  var1 = extract_variable(data, leftVar);
  var2 = extract_variable(data, rightVar);
  dataset = filter_countries(var1, var2);
  //console.table(dataset);
  //http://bl.ocks.org/phoebebright/raw/3176159/
  draw(dataset, leftVar, rightVar);
});


function extract_variable(arr, varName){
    return(arr.filter(function(d){return (d["Series Name"] == varName)&&(!isNaN(d["2014"]))}));

}

function filter_countries(var1, var2){
  // This function select the intersection of countries
  // between the selected variables and returns it
  // as an array.
  var countries1 = [],
      countries2 = [],
      countriesInt = [];
      countries1 = return_countries(var1);
      countries2 = return_countries(var2);
      // Obtaining the intersenction of countries between varaibles
      countriesInt = intersection_destructive(countries1,countries2).sort();
      return(join_variables(var1, var2, countriesInt));
}

function return_countries(arr){
  // This function returns an array containing all the Country Names
  // in arr
    var variable = [];
    for (var i = 0; i < arr.length; i++ ) {
        variable.push(arr[i]["Country Name"]);
    };
    return(variable);
}


function intersection_destructive(a, b)
// This function retunr the destructive intersection
// of array a and b
{
  var result = [];
  while( a.length > 0 && b.length > 0 )
  {  
     if      (a[0] < b[0] ){ a.shift(); }
     else if (a[0] > b[0] ){ b.shift(); }
     else /* they're equal */
     {
       result.push(a.shift());
       b.shift();
     }
  }
  return result;
}

function join_variables(v1, v2, list_of_rows){
  // Columns names are: the column used to join the variables, then as every var has the same Series Name, it will be obtained the first row Series anmes for each variable, v1, v2.

  var column_index = "Country Name";
  var column = "2014";
  var result = [];

 
  var temp1 =[], temp2 = [];
    for (var i = 0; i < list_of_rows.length; i++ ){
        temp_dict = {};
        temp1 = return_row(v1, column_index, list_of_rows[i])[column];
        temp2 = return_row(v2, column_index, list_of_rows[i])[column];
        temp_dict[column_index] = list_of_rows[i];
        temp_dict[v1[0]["Series Name"]] = temp1;
        temp_dict[v2[0]["Series Name"]] = temp2;
        result.push(temp_dict);
    };
    return(result);
}

function return_row(arr, column, value){
// Finds the row containing the element in value
    var i = 0,
        found = false;
    while (!found || i < arr.length){
      if (arr[i][column] == value){
        found = true;
        return(arr[i])
      }
      else{
        i += 1;
      }
    }

}

function get_accumulated(arr) {
    var bins = [], values = [], prev;
    for ( var i = 0; i < arr.length; i++ ) {
        if ( arr[i].bin !== prev ) {
            bins.push(arr[i].bin);
            values.push(arr[i].value);
        } else {
            values[values.length-1]+=arr[i].value;
        };
        prev = arr[i].bin;
    };

    return convert_to_array_of_objects([bins, values]);
}

function convert_to_array_of_objects(arr){
  // This function convert to standard array of objects
  // after extracting values in get_accumulated.
    var bins_values = [];
    for (var i = 0; i < arr[0].length; i++ ) {
      bins_values.push({
        bin: arr[0][i],
        value: arr[1][i]
      });
    };
    return bins_values;
}

function draw(data, leftVar, rightVar){
//http://databank.worldbank.org/data/reports.aspx?source=2&series=SH.XPD.PUBL&country=#advancedDownloadOptions
  k= data.length;


  var margin = {top: 20, right: 30, bottom: 30, left: 60, label: 5};
  font_size = 12,
  w     = 720,
  h    = 0.3 * data.length * font_size ;
  width = w - margin.left - margin.right,
  height = h- margin.top - margin.bottom;


  //chart = d3.select(".chart").append("svg")
  //           .attr("width",  width)
  //           .attr("height", height);
  var chart = d3.select("#chart").append("svg")
      .attr("width", width + margin.left + margin.right)
     .attr("height", height + margin.top + margin.bottom)
     .append("g")
     .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var leftScale = d3.scale.linear()
      .range([height,0]);
  
  leftScale.domain(d3.extent(data, function(d) { return Math.round(d[leftVar]); })).
  clamp(true);

  var rightScale = d3.scale.linear()
      .domain(d3.extent(data, function(d) { return Math.round(d[rightVar]); }))
      .range([height,0])
      .clamp(true);

  var leftAxis = d3.svg.axis()
      .scale(leftScale)
      .orient("left");
      /*.ticks(10)
      .tickSize(0);*/

  var rightAxis = d3.svg.axis()
      .scale(rightScale)
      .orient("right");
      /*.ticks(10)
      .tickSize(0);*/

  formatValue = d3.format(".2s");

  // Countries
  var country = chart.selectAll("g.country")
                  .data( data );
  country
    .enter()
    .append("g")
    .attr("class", "country");

  /*country
    .classed("missing", function(d) { return missing(d); });*/

  // Actions on mouseover
  country
    .on("mouseover", function(d,i) { var g = d3.select(this).classed("over", true);       // The class is used to remove the additional text later
      var info = g.append('text')
         .classed('info', true)
         .attr('x', w/2)
         .attr('y', 10)
         .text(d["Country Name"]);})
    .on("mouseout",  function(d,i) {d3.select(this).classed("over", false); d3.select(this).select('text.info').remove();});

  // ** Left column
  var left_column = country
                      .selectAll("text.label.start")
                        .data( function(d) { return [d[leftVar]]; } );
      left_column
       .enter()
        .append("text")
        .classed("label start", true)
        .attr("xml:space", "preserve")
        .style("font-size", font_size)
        .attr("x", margin.label)
        .attr("y", 0);

      left_column
        .attr("y", function(d,i) {return leftScale(d) })
        .text(function(d) { return d3.round(d, 2); });

      // ** Right column
      var right_column = country
                          .selectAll("text.label.end")
                          .data( function(d) { return [d[rightVar]]; } );

          right_column
           .enter()
            .append("text")
            .classed("label end", true)
            .attr("xml:space", "preserve")
            .style("font-size", font_size)
            .attr("x", width-margin.label)
            .attr("y", 0);

          right_column
            .attr("y", function(d,i) { return rightScale(d); })
            .text(function(d) { return d3.round(d, 2); });


    var country_column = country
                        .selectAll("text.label.country")
                          .data( function(d) { return [d]; } );
        country_column 
         .enter()
          .append("text")
          .classed("label country", true)
          .attr("xml:space", "preserve")
          .style("font-size", font_size)
          .attr("x", margin.label)
          .attr("y", 0);

        country_column 
          .attr("y", function(d,i) {return leftScale(d[leftVar]);  })
          .text(function(d) { return d["Country Name"]; });


      // ** Slope lines
      var line = country
                    .selectAll("line.slope")
                      .data( function(d) { return [d]; } );
          line
           .enter()
            .append("line")
            .attr("x1", margin.left)
            .attr("x2", width-margin.right)
            .attr("opacity", 0.5)
            .attr("y1", function(d) { return leftScale(d[leftVar] ); })
            .attr("y2", function(d) { return rightScale(d[rightVar] ); });

          line
            .classed("slope", function(d) { return d[leftVar] || d[rightVar]; })
            .attr("opacity", 0.5)
            .attr("y1", function(d,i) { return d[leftVar] && d[rightVar] ? Math.round( leftScale(d[leftVar]) - font_size/2 + 2) : null; })
            .attr("y2", function(d,i) { return d[leftVar] && d[rightVar]  ? Math.round( rightScale(d[rightVar])  - font_size/2 + 2) : null; });


      return chart;
    };

//     // Change year range
//     //
//     d3.selectAll(".label_year")
//       .on("mousemove", function() {
//             var $this = d3.select(this),
//                 box   = $this.node();

//             value  = d3.round(year_scale.range([2, box.offsetWidth-2]).invert(d3.mouse(this)[0]))
//             d3.select(this).text(value)

//             if ( d3.select("#from").text() > d3.select("#to").text()   ) {
//               d3.select("#from").text( d3.select("#to").text() )
//             }
//             if ( d3.select("#to").text()   < d3.select("#from").text() ) {
//               d3.select("#to").text( d3.select("#from") )
//             }

//             return update( d3.select("#from").text(), d3.select("#to").text() );
//       });


//    // return update( d3.first(years), d3.last(years) );

// }




function group_data(data, coeff=10){
  var nested_data = d3.nest()
  .key(function(d) { return Math.round(d.bin / coeff) * coeff})
  .rollup(function(a) {return d3.sum(a, function(d) {return d.value})})
  .entries(data)
  return nested_data;
}


</script><!DOCTYPE html>
<meta charset="utf-8">
<head>
<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">

<style>

    body{ 
      color: #444; 
      background: #f3f3f3; 
      font: normal 12px "Lato", sans-serif;
      margin: 2em; }
    header { 
      margin: 0 0 20px 220px; 
      border-bottom: 1px solid #6c6c6c; 
      width: 360px; 
      position: relative; }

    h1     { 
      font-size: 28px; 
      font-weight: normal; 
      text-shadow: #fff 0 1px 0; 
      margin: 0 0 0 0; 
      padding: 0; 
    }
    small  { 
      color: #a3a3a3; 
      font-size: 12px; 
      position: absolute; 
      bottom: -1.8em; 
      left: 0;
    }
    a{ 
      color: #a3a3a3; 
    }

    span.label_year:hover { 
      cursor: ew-resize; 
    }

    text.label { fill: #444; }
    text.label.start { text-anchor: end; }
    line.slope { stroke: #444; stroke-width: 1; }

    .missing text.label { display: none; }
    .missing line.slope { display: none; }

    .over text.label { fill: #bb2629; }
    .over line.slope { stroke: #bb2629; stroke-width: 2; }


</style>
<script src="//d3js.org/d3.v3.min.js" charset="utf-8"></script>
</head>
<div id="chart"></div>

<script>
// REFERENCES:
//http://bl.ocks.org/zbjornson/2547496

// var w = 960,
//     h = 500;

//var margin = {top: 20, right: 30, bottom: 30, left: 60};
//     width = w - margin.left - margin.right,
//     height = h- margin.top - margin.bottom;

// var font_size = 12
// var interval = 20;

// var chart = d3.select(".chart").append("svg")
//     .attr("width", width + margin.left + margin.right)
//     .attr("height", height + margin.top + margin.bottom)
//     .append("g")
//     .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
function get_bin(edad, interval = 10) {
  return Math.floor(parseInt(edad) / interval) * interval;
}

var hombres = [];
var mujeres = [];
var p = []

var dataset = {}; 
var data_series= [];

d3.csv("./data/data_dict.csv",function(error, data){ 
    data.forEach(function(d) {
        data_series.push(d["Indicator Name"]);
    });
});

indicator_pair = [data_series[1], data_series[2]];
indicator_list = []
d3.csv("./data/data.csv",function(error, data){

    data.forEach(function(d) {
    //selection of the year column
        d["2014"] = +d["2014"];
    });
  leftVar = "Health expenditure per capita (current US$)";
  rightVar = "Life expectancy at birth, total (years)";
  var1 = extract_variable(data, leftVar);
  var2 = extract_variable(data, rightVar);
  dataset = filter_countries(var1, var2);
  //console.table(dataset);
  //http://bl.ocks.org/phoebebright/raw/3176159/
  draw(dataset, leftVar, rightVar);
});


function extract_variable(arr, varName){
    return(arr.filter(function(d){return (d["Series Name"] == varName)&&(!isNaN(d["2014"]))}));

}

function filter_countries(var1, var2){
  // This function select the intersection of countries
  // between the selected variables and returns it
  // as an array.
  var countries1 = [],
      countries2 = [],
      countriesInt = [];
      countries1 = return_countries(var1);
      countries2 = return_countries(var2);
      // Obtaining the intersenction of countries between varaibles
      countriesInt = intersection_destructive(countries1,countries2).sort();
      return(join_variables(var1, var2, countriesInt));
}

function return_countries(arr){
  // This function returns an array containing all the Country Names
  // in arr
    var variable = [];
    for (var i = 0; i < arr.length; i++ ) {
        variable.push(arr[i]["Country Name"]);
    };
    return(variable);
}


function intersection_destructive(a, b)
// This function retunr the destructive intersection
// of array a and b
{
  var result = [];
  while( a.length > 0 && b.length > 0 )
  {  
     if      (a[0] < b[0] ){ a.shift(); }
     else if (a[0] > b[0] ){ b.shift(); }
     else /* they're equal */
     {
       result.push(a.shift());
       b.shift();
     }
  }
  return result;
}

function join_variables(v1, v2, list_of_rows){
  // Columns names are: the column used to join the variables, then as every var has the same Series Name, it will be obtained the first row Series anmes for each variable, v1, v2.

  var column_index = "Country Name";
  var column = "2014";
  var result = [];

 
  var temp1 =[], temp2 = [];
    for (var i = 0; i < list_of_rows.length; i++ ){
        temp_dict = {};
        temp1 = return_row(v1, column_index, list_of_rows[i])[column];
        temp2 = return_row(v2, column_index, list_of_rows[i])[column];
        temp_dict[column_index] = list_of_rows[i];
        temp_dict[v1[0]["Series Name"]] = temp1;
        temp_dict[v2[0]["Series Name"]] = temp2;
        result.push(temp_dict);
    };
    return(result);
}

function return_row(arr, column, value){
// Finds the row containing the element in value
    var i = 0,
        found = false;
    while (!found || i < arr.length){
      if (arr[i][column] == value){
        found = true;
        return(arr[i])
      }
      else{
        i += 1;
      }
    }

}

function get_accumulated(arr) {
    var bins = [], values = [], prev;
    for ( var i = 0; i < arr.length; i++ ) {
        if ( arr[i].bin !== prev ) {
            bins.push(arr[i].bin);
            values.push(arr[i].value);
        } else {
            values[values.length-1]+=arr[i].value;
        };
        prev = arr[i].bin;
    };

    return convert_to_array_of_objects([bins, values]);
}

function convert_to_array_of_objects(arr){
  // This function convert to standard array of objects
  // after extracting values in get_accumulated.
    var bins_values = [];
    for (var i = 0; i < arr[0].length; i++ ) {
      bins_values.push({
        bin: arr[0][i],
        value: arr[1][i]
      });
    };
    return bins_values;
}

function draw(data, leftVar, rightVar){
//http://databank.worldbank.org/data/reports.aspx?source=2&series=SH.XPD.PUBL&country=#advancedDownloadOptions
  k= data.length;


  var margin = {top: 20, right: 30, bottom: 30, left: 60, label: 5};
  font_size = 12,
  w     = 720,
  h    = 0.3 * data.length * font_size ;
  width = w - margin.left - margin.right,
  height = h- margin.top - margin.bottom;


  //chart = d3.select(".chart").append("svg")
  //           .attr("width",  width)
  //           .attr("height", height);
  var chart = d3.select("#chart").append("svg")
      .attr("width", width + margin.left + margin.right)
     .attr("height", height + margin.top + margin.bottom)
     .append("g")
     .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var leftScale = d3.scale.linear()
      .range([height,0]);
  
  leftScale.domain(d3.extent(data, function(d) { return Math.round(d[leftVar]); })).
  clamp(true);

  var rightScale = d3.scale.linear()
      .domain(d3.extent(data, function(d) { return Math.round(d[rightVar]); }))
      .range([height,0])
      .clamp(true);

  var leftAxis = d3.svg.axis()
      .scale(leftScale)
      .orient("left");
      /*.ticks(10)
      .tickSize(0);*/

  var rightAxis = d3.svg.axis()
      .scale(rightScale)
      .orient("right");
      /*.ticks(10)
      .tickSize(0);*/

  formatValue = d3.format(".2s");

  // Countries
  var country = chart.selectAll("g.country")
                  .data( data );
  country
    .enter()
    .append("g")
    .attr("class", "country");

  /*country
    .classed("missing", function(d) { return missing(d); });*/

  // Actions on mouseover
  country
    .on("mouseover", function(d,i) { var g = d3.select(this).classed("over", true);       // The class is used to remove the additional text later
      var info = g.append('text')
         .classed('info', true)
         .attr('x', w/2)
         .attr('y', 10)
         .text(d["Country Name"]);})
    .on("mouseout",  function(d,i) {d3.select(this).classed("over", false); d3.select(this).select('text.info').remove();});

  // ** Left column
  var left_column = country
                      .selectAll("text.label.start")
                        .data( function(d) { return [d[leftVar]]; } );
      left_column
       .enter()
        .append("text")
        .classed("label start", true)
        .attr("xml:space", "preserve")
        .style("font-size", font_size)
        .attr("x", margin.label)
        .attr("y", 0);

      left_column
        .attr("y", function(d,i) {return leftScale(d) })
        .text(function(d) { return d3.round(d, 2); });

      // ** Right column
      var right_column = country
                          .selectAll("text.label.end")
                          .data( function(d) { return [d[rightVar]]; } );

          right_column
           .enter()
            .append("text")
            .classed("label end", true)
            .attr("xml:space", "preserve")
            .style("font-size", font_size)
            .attr("x", width-margin.label)
            .attr("y", 0);

          right_column
            .attr("y", function(d,i) { return rightScale(d); })
            .text(function(d) { return d3.round(d, 2); });


    var country_column = country
                        .selectAll("text.label.country")
                          .data( function(d) { return [d]; } );
        country_column 
         .enter()
          .append("text")
          .classed("label country", true)
          .attr("xml:space", "preserve")
          .style("font-size", font_size)
          .attr("x", margin.label)
          .attr("y", 0);

        country_column 
          .attr("y", function(d,i) {return leftScale(d[leftVar]);  })
          .text(function(d) { return d["Country Name"]; });


      // ** Slope lines
      var line = country
                    .selectAll("line.slope")
                      .data( function(d) { return [d]; } );
          line
           .enter()
            .append("line")
            .attr("x1", margin.left)
            .attr("x2", width-margin.right)
            .attr("opacity", 0.5)
            .attr("y1", function(d) { return leftScale(d[leftVar] ); })
            .attr("y2", function(d) { return rightScale(d[rightVar] ); });

          line
            .classed("slope", function(d) { return d[leftVar] || d[rightVar]; })
            .attr("opacity", 0.5)
            .attr("y1", function(d,i) { return d[leftVar] && d[rightVar] ? Math.round( leftScale(d[leftVar]) - font_size/2 + 2) : null; })
            .attr("y2", function(d,i) { return d[leftVar] && d[rightVar]  ? Math.round( rightScale(d[rightVar])  - font_size/2 + 2) : null; });


      return chart;
    };

//     // Change year range
//     //
//     d3.selectAll(".label_year")
//       .on("mousemove", function() {
//             var $this = d3.select(this),
//                 box   = $this.node();

//             value  = d3.round(year_scale.range([2, box.offsetWidth-2]).invert(d3.mouse(this)[0]))
//             d3.select(this).text(value)

//             if ( d3.select("#from").text() > d3.select("#to").text()   ) {
//               d3.select("#from").text( d3.select("#to").text() )
//             }
//             if ( d3.select("#to").text()   < d3.select("#from").text() ) {
//               d3.select("#to").text( d3.select("#from") )
//             }

//             return update( d3.select("#from").text(), d3.select("#to").text() );
//       });


//    // return update( d3.first(years), d3.last(years) );

// }




function group_data(data, coeff=10){
  var nested_data = d3.nest()
  .key(function(d) { return Math.round(d.bin / coeff) * coeff})
  .rollup(function(a) {return d3.sum(a, function(d) {return d.value})})
  .entries(data)
  return nested_data;
}


</script>